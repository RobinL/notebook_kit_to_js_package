import type { TranspiledCell } from "./transpile.js";

/**
 * Build the targeting identifiers for a cell.
 * Users can target cells by:
 * - cell id (e.g., "cell-2" from id="2")
 * - output attribute if set (e.g., "bliiip" from output="bliiip")
 * - any of the outputs array members (e.g., "viewof one", "one", etc.)
 */
function buildCellTargets(cell: TranspiledCell): string[] {
    const targets: string[] = [];

    // 1. Cell ID (prefixed with "cell-" to match canonical format)
    targets.push(`cell-${cell.id}`);

    // 2. Output attribute (if set)
    if (cell.output) {
        targets.push(cell.output);
    }

    // 3. All outputs (without "viewof " prefix for convenience)
    for (const output of cell.outputs) {
        if (output.startsWith("viewof ")) {
            targets.push(output.slice("viewof ".length));
        } else {
            targets.push(output);
        }
    }

    // Deduplicate while preserving order
    return [...new Set(targets)];
}

export function generateDefineJs(cells: TranspiledCell[]): string {
    const lines: string[] = [
        `// Auto-generated by notebook-to-lib`,
        ``,
        `// Cell metadata for targeting (used by mount())`,
        `export const cells = ${JSON.stringify(
            cells.map(cell => ({
                id: cell.id,
                index: cell.index,
                output: cell.output,
                targets: buildCellTargets(cell),
                inputs: cell.inputs,
                outputs: cell.outputs,
                isView: cell.viewName !== undefined
            })),
            null,
            2
        )};`,
        ``,
        `export default function define(runtime, observer) {`,
        `  const main = runtime.module();`
    ];

    for (const cell of cells) {
        const inputs = JSON.stringify(cell.inputs);
        const cellFnName = `_${cell.id.replace(/[^a-zA-Z0-9]/g, '_')}`;

        // notebook-kit returns a function expression in transpiled.body.
        lines.push(`  const ${cellFnName} = ${cell.body};`);

        if (cell.outputs.length === 0) {
            // Anonymous / side-effect cell (e.g. markdown)
            lines.push(`  main.variable(observer()).define(${inputs}, ${cellFnName});`);
            continue;
        }

        for (const output of cell.outputs) {
            if (output.startsWith("viewof ")) {
                const viewName = output.slice("viewof ".length);
                lines.push(
                    `  main.variable(observer(${JSON.stringify(output)})).define(${JSON.stringify(output)}, ${inputs}, (...args) => Promise.resolve(${cellFnName}(...args)).then((o) => (o && typeof o === "object" && ${JSON.stringify(viewName)} in o) ? o[${JSON.stringify(viewName)}] : o));`
                );

                // Standard Observable pattern: the value cell is derived from the view cell.
                // main.variable(observer("one")).define("one", ["Generators", "viewof one"], (G, _) => G.input(_));
                lines.push(
                    `  main.variable(observer(${JSON.stringify(viewName)})).define(${JSON.stringify(viewName)}, ["Generators", ${JSON.stringify(output)}], (G, _) => G.input(_));`
                );
            } else {
                lines.push(
                    `  main.variable(observer(${JSON.stringify(output)})).define(${JSON.stringify(output)}, ${inputs}, (...args) => Promise.resolve(${cellFnName}(...args)).then((o) => (o && typeof o === "object" && ${JSON.stringify(output)} in o) ? o[${JSON.stringify(output)}] : o));`
                );
            }
        }
    }

    lines.push(`  return main;`);
    lines.push(`}`);

    return lines.join("\n");
}

export function generateIndexJs(): string {
    return [
        `export { default, cells } from "./define.js";`,
        `export { Runtime, Inspector, Library, Inputs, createLibrary, mount } from "./runtime.js";`
    ].join("\n");
}

export function generateRuntimeJs(): string {
    return [
        `import { Runtime as ObservableRuntime } from "@observablehq/runtime";`,
        `import { Inspector } from "@observablehq/inspector";`,
        `import { Library } from "@observablehq/stdlib";`,
        `import * as Inputs from "@observablehq/inputs";`,
        `import define, { cells } from "./define.js";`,
        ``,
        `export { Inspector, Library, Inputs };`,
        ``,
        `export function createLibrary() {`,
        `  const library = new Library();`,
        `  // notebook-kit HTML exports assume Inputs is globally available; we provide it via the library.`,
        `  return Object.assign(library, { Inputs });`,
        `}`,
        ``,
        `// Export a Runtime class that comes pre-wired with stdlib + Inputs so consumers can do:`,
        `//   new Runtime().module(define, Inspector.into(...))`,
        `export class Runtime extends ObservableRuntime {`,
        `  constructor(builtins = createLibrary()) {`,
        `    super(builtins);`,
        `  }`,
        `}`,
        ``,
        `/**`,
        ` * Mount the notebook into a container with optional cell targeting.`,
        ` *`,
        ` * Cell targeting supports three methods:`,
        ` * 1. By cell id: data-cell="cell-2" (matches cell with id="2")`,
        ` * 2. By output attribute: data-cell="bliiip" (matches cell with output="bliiip")`,
        ` * 3. By output name: data-cell="one" (matches cell that outputs "one" or "viewof one")`,
        ` *`,
        ` * @param {Element} [container=document.body] - Default container for unmatched cells`,
        ` * @param {Object} [options]`,
        ` * @param {Record<string, Element>} [options.targets] - Map of target identifier -> target element`,
        ` * @param {boolean} [options.appendUnmatched=true] - Whether to append unmatched cells to the container`,
        ` * @returns {{ runtime: Runtime, main: Module }} - The runtime and main module for cleanup`,
        ` */`,
        `export function mount(container = document.body, options = {}) {`,
        `  const { targets = {}, appendUnmatched = true } = options;`,
        ``,
        `  // Build a lookup: target identifier -> set of observable variable names that belong to it`,
        `  // For view cells: the primary display is "viewof <name>", we suppress "<name>" to avoid duplicates`,
        `  const cellTargetToOutputs = new Map();`,
        `  const suppressedOutputs = new Set();`,
        ``,
        `  for (const cell of cells) {`,
        `    const primaryOutputs = [];`,
        `    for (const output of cell.outputs) {`,
        `      if (output.startsWith("viewof ")) {`,
        `        primaryOutputs.push(output);`,
        `        // Suppress the derived value variable (e.g. "one" when we have "viewof one")`,
        `        suppressedOutputs.add(output.slice("viewof ".length));`,
        `      } else {`,
        `        primaryOutputs.push(output);`,
        `      }`,
        `    }`,
        `    // Anonymous cells (no outputs) still need to render`,
        `    if (primaryOutputs.length === 0) {`,
        `      primaryOutputs.push(null); // marker for anonymous cell`,
        `    }`,
        `    for (const target of cell.targets) {`,
        `      cellTargetToOutputs.set(target, { outputs: primaryOutputs, cell });`,
        `    }`,
        `  }`,
        ``,
        `  // Helper: find target element for a cell`,
        `  function findTarget(cell) {`,
        `    // 1. Try targets map (programmatic targeting)`,
        `    for (const target of cell.targets) {`,
        `      if (targets[target]) return targets[target];`,
        `    }`,
        `    // 2. Try data-cell attribute in document`,
        `    for (const target of cell.targets) {`,
        `      const escaped = CSS.escape(target);`,
        `      const el = document.querySelector(\`[data-cell="\${escaped}"]\`);`,
        `      if (el) return el;`,
        `    }`,
        `    return null;`,
        `  }`,
        ``,
        `  // Map output variable name -> target element`,
        `  const outputToTarget = new Map();`,
        `  const unmatchedContainer = container;`,
        ``,
        `  for (const cell of cells) {`,
        `    const target = findTarget(cell);`,
        `    if (target) {`,
        `      // All outputs of this cell go to this target`,
        `      for (const output of cell.outputs) {`,
        `        outputToTarget.set(output, target);`,
        `      }`,
        `      // Also handle anonymous cells`,
        `      if (cell.outputs.length === 0) {`,
        `        outputToTarget.set(\`__anon_\${cell.index}\`, target);`,
        `      }`,
        `    }`,
        `  }`,
        ``,
        `  const runtime = new Runtime();`,
        ``,
        `  // Track anonymous cell counter for matching`,
        `  let anonIndex = 0;`,
        `  const cellIndexToAnonKey = new Map();`,
        `  for (const cell of cells) {`,
        `    if (cell.outputs.length === 0) {`,
        `      cellIndexToAnonKey.set(cell.index, \`__anon_\${cell.index}\`);`,
        `    }`,
        `  }`,
        ``,
        `  const main = runtime.module(define, (name) => {`,
        `    // Suppress derived value outputs for view cells`,
        `    if (suppressedOutputs.has(name)) {`,
        `      return true; // Don't render`,
        `    }`,
        ``,
        `    // Check if this output has a specific target`,
        `    if (outputToTarget.has(name)) {`,
        `      return new Inspector(outputToTarget.get(name));`,
        `    }`,
        ``,
        `    // Handle anonymous cells (name is undefined)`,
        `    if (name === undefined) {`,
        `      // Find the next anonymous cell`,
        `      for (const [idx, key] of cellIndexToAnonKey) {`,
        `        if (outputToTarget.has(key)) {`,
        `          cellIndexToAnonKey.delete(idx);`,
        `          return new Inspector(outputToTarget.get(key));`,
        `        }`,
        `        cellIndexToAnonKey.delete(idx);`,
        `        break;`,
        `      }`,
        `    }`,
        ``,
        `    // Fallback: append to container if allowed`,
        `    if (appendUnmatched) {`,
        `      const div = document.createElement("div");`,
        `      div.className = "observablehq-cell";`,
        `      unmatchedContainer.appendChild(div);`,
        `      return new Inspector(div);`,
        `    }`,
        ``,
        `    return true; // Don't render`,
        `  });`,
        ``,
        `  return { runtime, main };`,
        `}`
    ].join("\n");
}

export function generatePackageJson(
    name: string,
    detectedDependencies: Set<string>,
    dependencySpecs: Record<string, string> = {}
): string {
    const depsObj: Record<string, string> = {
        "@observablehq/runtime": "^5.0.0",
        "@observablehq/inspector": "latest",
        "@observablehq/stdlib": "latest",
        "@observablehq/inputs": "latest"
    };

    // Apply explicit specs (can override defaults)
    for (const [dep, spec] of Object.entries(dependencySpecs)) {
        depsObj[dep] = spec;
    }

    // Add detected dependencies
    // We default to "latest" because we extracted names but not versions
    detectedDependencies.forEach(dep => {
        if (!(dep in depsObj)) {
            depsObj[dep] = "latest";
        }
    });

    return JSON.stringify({
        name,
        version: "0.1.0",
        description: "Converted Observable Notebook",
        type: "module",
        main: "src/index.js",
        files: ["src"],
        dependencies: depsObj
    }, null, 2);
}

export function generateReadme(name: string): string {
    return `# ${name}

This library was generated from an Observable Notebook.

## Usage

\`\`\`javascript
import define from "${name}";
import { Runtime, Inspector } from "${name}";

new Runtime().module(define, Inspector.into(document.body));
\`\`\`
`;
}
