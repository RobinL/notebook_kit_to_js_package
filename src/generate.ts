import type { TranspiledCell } from "./transpile.js";

/**
 * Build the names array for a cell (used for data-cell targeting)
 * - Explicit data-name (if any)
 * - cell:<index> as stable fallback
 */
function buildCellNames(cell: TranspiledCell): string[] {
    const names: string[] = [];
    if (cell.name) {
        names.push(cell.name);
    }
    names.push(`cell:${cell.index}`);
    return names;
}

export function generateDefineJs(cells: TranspiledCell[]): string {
    const lines: string[] = [
        `// Auto-generated by notebook-to-lib`,
        ``,
        `// Cell metadata for targeting (used by mount())`,
        `export const cells = ${JSON.stringify(
            cells.map(cell => ({
                id: cell.id,
                index: cell.index,
                names: buildCellNames(cell),
                inputs: cell.inputs,
                outputs: cell.outputs,
                isView: cell.viewName !== undefined
            })),
            null,
            2
        )};`,
        ``,
        `export default function define(runtime, observer) {`,
        `  const main = runtime.module();`
    ];

    for (const cell of cells) {
        const inputs = JSON.stringify(cell.inputs);
        const cellFnName = `_${cell.id}`;

        // notebook-kit returns a function expression in transpiled.body.
        lines.push(`  const ${cellFnName} = ${cell.body};`);

        if (cell.outputs.length === 0) {
            // Anonymous / side-effect cell (e.g. markdown)
            if (cell.name) {
                lines.push(`  main.variable(observer("${cell.name}")).define(${inputs}, ${cellFnName});`);
            } else {
                lines.push(`  main.variable(observer()).define(${inputs}, ${cellFnName});`);
            }
            continue;
        }

        for (const output of cell.outputs) {
            if (output.startsWith("viewof ")) {
                const viewName = output.slice("viewof ".length);
                lines.push(
                    `  main.variable(observer(${JSON.stringify(output)})).define(${JSON.stringify(output)}, ${inputs}, (...args) => Promise.resolve(${cellFnName}(...args)).then((o) => (o && typeof o === "object" && ${JSON.stringify(viewName)} in o) ? o[${JSON.stringify(viewName)}] : o));`
                );

                // Standard Observable pattern: the value cell is derived from the view cell.
                // main.variable(observer("one")).define("one", ["Generators", "viewof one"], (G, _) => G.input(_));
                lines.push(
                    `  main.variable(observer(${JSON.stringify(viewName)})).define(${JSON.stringify(viewName)}, ["Generators", ${JSON.stringify(output)}], (G, _) => G.input(_));`
                );
            } else {
                lines.push(
                    `  main.variable(observer(${JSON.stringify(output)})).define(${JSON.stringify(output)}, ${inputs}, (...args) => Promise.resolve(${cellFnName}(...args)).then((o) => (o && typeof o === "object" && ${JSON.stringify(output)} in o) ? o[${JSON.stringify(output)}] : o));`
                );
            }
        }
    }

    lines.push(`  return main;`);
    lines.push(`}`);

    return lines.join("\n");
}

export function generateIndexJs(): string {
    return [
        `export { default, cells } from "./define.js";`,
        `export { Runtime, Inspector, Library, Inputs, createLibrary, mount } from "./runtime.js";`
    ].join("\n");
}

export interface GenerateRuntimeOptions {
    /**
     * If true, the generated runtime provides a local `md` tagged template literal
     * implementation (via the `marked` package) rather than relying on stdlib's
     * CDN-based lazy loader.
     */
    includeMarkdown?: boolean;
}

export function generateRuntimeJs(options: GenerateRuntimeOptions = {}): string {
    const { includeMarkdown = false } = options;

    const lines: string[] = [
        `import { Runtime as ObservableRuntime } from "@observablehq/runtime";`,
        `import { Inspector } from "@observablehq/inspector";`,
        `import { Library } from "@observablehq/stdlib";`,
        `import * as Inputs from "@observablehq/inputs";`,
        ...(includeMarkdown ? [`import { marked } from "marked";`] : []),
        `import define, { cells } from "./define.js";`,
        ``,
        `export { Inspector, Library, Inputs };`,
        ``
    ];

    if (includeMarkdown) {
        lines.push(
            `marked.setOptions({ langPrefix: "" });`,
            ``,
            `function md(strings, ...values) {`,
            `  // Minimal md tagged template implementation for notebook markdown cells.`,
            `  // Note: embedded expressions are stringified; DOM embedding is not supported here.`,
            `  const text = String.raw({ raw: strings }, ...values.map(v => v == null ? "" : String(v)));`,
            `  const root = document.createElement("div");`,
            `  root.innerHTML = String(marked.parse(text)).trim();`,
            `  return root;`,
            `}`,
            ``
        );
    }

    lines.push(
        `export function createLibrary() {`,
        `  const library = new Library();`,
        `  // notebook-kit HTML exports assume Inputs is globally available; we provide it via the library.`,
        ...(includeMarkdown
            ? [
                `  // Provide a local md tag to avoid stdlib's CDN-based markdown loader.`,
                `  library.md = () => md;`
            ]
            : []),
        `  return Object.assign(library, { Inputs });`,
        `}`,
        ``,
        `// Export a Runtime class that comes pre-wired with stdlib + Inputs so consumers can do:`,
        `//   new Runtime().module(define, Inspector.into(...))`,
        `export class Runtime extends ObservableRuntime {`,
        `  constructor(builtins = createLibrary()) {`,
        `    super(builtins);`,
        `  }`,
        `}`,
        ``,
        `/**`,
        ` * Mount the notebook into a container with optional cell targeting.`,
        ` *`,
        ` * @param {Element} [container=document.body] - Default container for unmatched cells`,
        ` * @param {Object} [options]`,
        ` * @param {Record<string, Element>} [options.targets] - Map of cell name -> target element`,
        ` * @param {boolean} [options.appendUnmatched=true] - Whether to append unmatched cells to the container`,
        ` * @returns {{ runtime: Runtime, main: Module }} - The runtime and main module for cleanup`,
        ` */`,
        `export function mount(container = document.body, options = {}) {`,
        `  const { targets = {}, appendUnmatched = true } = options;`,
        ``,
        `  // Build a lookup: cell name -> set of observable variable names that belong to it`,
        `  // For view cells: the primary display is "viewof <name>", we suppress "<name>" to avoid duplicates`,
        `  const cellNameToOutputs = new Map();`,
        `  const suppressedOutputs = new Set();`,
        ``,
        `  for (const cell of cells) {`,
        `    const primaryOutputs = [];`,
        `    for (const output of cell.outputs) {`,
        `      if (output.startsWith("viewof ")) {`,
        `        primaryOutputs.push(output);`,
        `        // Suppress the derived value variable (e.g. "one" when we have "viewof one")`,
        `        suppressedOutputs.add(output.slice("viewof ".length));`,
        `      } else {`,
        `        primaryOutputs.push(output);`,
        `      }`,
        `    }`,
        `    // Anonymous cells (no outputs) still need to render`,
        `    if (primaryOutputs.length === 0) {`,
        `      primaryOutputs.push(null); // marker for anonymous cell`,
        `    }`,
        `    for (const name of cell.names) {`,
        `      cellNameToOutputs.set(name, { outputs: primaryOutputs, cell });`,
        `    }`,
        `  }`,
        ``,
        `  // Helper: find target element for a cell`,
        `  function findTarget(cell) {`,
        `    // 1. Try targets map`,
        `    for (const name of cell.names) {`,
        `      if (targets[name]) return targets[name];`,
        `    }`,
        `    // 2. Try data-cell attribute in document`,
        `    for (const name of cell.names) {`,
        `      const escaped = CSS.escape(name);`,
        `      const el = document.querySelector(\`[data-cell="\${escaped}"]\`);`,
        `      if (el) return el;`,
        `    }`,
        `    return null;`,
        `  }`,
        ``,
        `  // Map output variable name -> target element`,
        `  const outputToTarget = new Map();`,
        `  const unmatchedContainer = container;`,
        ``,
        `  for (const cell of cells) {`,
        `    const target = findTarget(cell);`,
        `    if (target) {`,
        `      // All outputs of this cell go to this target`,
        `      for (const output of cell.outputs) {`,
        `        outputToTarget.set(output, target);`,
        `      }`,
        `      // Also handle anonymous cells`,
        `      if (cell.outputs.length === 0) {`,
        `        outputToTarget.set(\`__anon_\${cell.index}\`, target);`,
        `      }`,
        `    }`,
        `  }`,
        ``,
        `  const runtime = new Runtime();`,
        ``,
        `  // Track anonymous cell counter for matching`,
        `  let anonIndex = 0;`,
        `  const cellIndexToAnonKey = new Map();`,
        `  for (const cell of cells) {`,
        `    if (cell.outputs.length === 0) {`,
        `      cellIndexToAnonKey.set(cell.index, \`__anon_\${cell.index}\`);`,
        `    }`,
        `  }`,
        ``,
        `  const main = runtime.module(define, (name) => {`,
        `    // Suppress derived value outputs for view cells`,
        `    if (suppressedOutputs.has(name)) {`,
        `      return true; // Don't render`,
        `    }`,
        ``,
        `    // Check if this output has a specific target`,
        `    if (outputToTarget.has(name)) {`,
        `      return new Inspector(outputToTarget.get(name));`,
        `    }`,
        ``,
        `    // Handle anonymous cells (name is undefined)`,
        `    if (name === undefined) {`,
        `      // Find the next anonymous cell`,
        `      for (const [idx, key] of cellIndexToAnonKey) {`,
        `        if (outputToTarget.has(key)) {`,
        `          cellIndexToAnonKey.delete(idx);`,
        `          return new Inspector(outputToTarget.get(key));`,
        `        }`,
        `        cellIndexToAnonKey.delete(idx);`,
        `        break;`,
        `      }`,
        `    }`,
        ``,
        `    // Fallback: append to container if allowed`,
        `    if (appendUnmatched) {`,
        `      const div = document.createElement("div");`,
        `      div.className = "observablehq-cell";`,
        `      unmatchedContainer.appendChild(div);`,
        `      return new Inspector(div);`,
        `    }`,
        ``,
        `    return true; // Don't render`,
        `  });`,
        ``,
        `  return { runtime, main };`,
        `}`
    );

    return lines.join("\n");
}

export interface GeneratePackageOptions {
    includeMarkdown?: boolean;
}

export function generatePackageJson(
    name: string,
    dependencies: Set<string>,
    options: GeneratePackageOptions = {}
): string {
    const depsObj: Record<string, string> = {
        "@observablehq/runtime": "^5.0.0",
        "@observablehq/inspector": "latest",
        "@observablehq/stdlib": "latest",
        "@observablehq/inputs": "latest"
    };

    if (options.includeMarkdown) {
        depsObj["marked"] = "latest";
    }

    // Add detected dependencies
    // We default to "latest" because we extracted names but not versions
    dependencies.forEach(dep => {
        depsObj[dep] = "latest";
    });

    return JSON.stringify({
        name,
        version: "0.1.0",
        description: "Converted Observable Notebook",
        type: "module",
        main: "src/index.js",
        files: ["src"],
        dependencies: depsObj
    }, null, 2);
}

export function generateReadme(name: string): string {
    return `# ${name}

This library was generated from an Observable Notebook.

## Usage

\`\`\`javascript
import define from "${name}";
import { Runtime, Inspector } from "${name}";

new Runtime().module(define, Inspector.into(document.body));
\`\`\`
`;
}
