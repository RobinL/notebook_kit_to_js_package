import type { TranspiledCell } from "./transpile.js";

export function generateDefineJs(cells: TranspiledCell[]): string {
    const lines: string[] = [
        `// Auto-generated by notebook-to-lib`,
        ``,
        `// Cell metadata for targeting and display (used by mount())`,
        `export const cells = ${JSON.stringify(
            cells.map(cell => ({
                id: cell.id,
                index: cell.index,
                output: cell.output,
                inputs: cell.inputs,
                outputs: cell.outputs,
                // notebook-kit doesn't treat view() as a declaration type; view() is an input helper.
                isView: false,
                autodisplay: cell.autodisplay,
                usesDisplay: cell.usesDisplay,
                usesView: cell.usesView
            })),
            null,
            2
        )};`,
        ``,
        `// Cell bodies as functions`,
        `export const cellBodies = {`
    ];

    // Export cell bodies separately so runtime can access them
    for (const cell of cells) {
        const cellKey = `cell_${cell.id.replace(/[^a-zA-Z0-9]/g, '_')}`;
        lines.push(`  ${JSON.stringify(cellKey)}: ${cell.body},`);
    }
    lines.push(`};`);
    lines.push(``);

    // Keep a define() export for compatibility, but avoid re-running cells per output.
    // This is a dataflow-oriented define() (Observable runtime style); for canonical
    // notebook-kit rendering semantics (cell roots + display()), prefer mount().
    lines.push(`export default function define(runtime, observer) {`);
    lines.push(`  const main = runtime.module();`);

    for (const cell of cells) {
        const cellFnName = `_${cell.id.replace(/[^a-zA-Z0-9]/g, '_')}`;
        const inputs = JSON.stringify(cell.inputs.filter(i => i !== "display" && i !== "view"));
        const vid = cell.output ?? (cell.outputs.length ? `cell ${cell.id}` : null);
        const vidJson = vid === null ? "null" : JSON.stringify(vid);

        lines.push(`  const ${cellFnName} = ${cell.body};`);

        // Define the primary cell variable once.
        if (cell.outputs.length === 0) {
            // Anonymous / side-effect cell (e.g. markdown)
            lines.push(`  main.variable(observer()).define(${inputs}, ${cellFnName});`);
            continue;
        }

        lines.push(`  main.variable(observer(${vidJson})).define(${vidJson}, ${inputs}, ${cellFnName});`);

        // Define named outputs as projections from the cell variable (only when
        // the cell doesn't have an explicit output name).
        if (cell.output == null) {
            for (const output of cell.outputs) {
                lines.push(
                    `  main.variable(observer(${JSON.stringify(output)})).define(${JSON.stringify(output)}, [${vidJson}], (exports) => exports && typeof exports === "object" && ${JSON.stringify(output)} in exports ? exports[${JSON.stringify(output)}] : exports);`
                );
            }
        }
    }

    lines.push(`  return main;`);
    lines.push(`}`);

    return lines.join("\n");
}

export function generateIndexJs(): string {
    return [
        `export { default, cells } from "./define.js";`,
        `export { Runtime, Inspector, Library, Inputs, createLibrary, mount } from "./runtime.js";`
    ].join("\n");
}

export function generateRuntimeJs(): string {
    return `import { Runtime as ObservableRuntime } from "@observablehq/runtime";
import { Inspector } from "@observablehq/inspector";
import { Library } from "@observablehq/stdlib";
import * as Inputs from "@observablehq/inputs";
import define, { cells, cellBodies } from "./define.js";

export { Inspector, Library, Inputs };

export function createLibrary() {
  const library = new Library();
  return Object.assign(library, { Inputs });
}

export class Runtime extends ObservableRuntime {
  constructor(builtins = createLibrary()) {
    super(builtins);
  }
}

// ============================================================================
// Generators.input (vendored minimal helper from notebook-kit)
// ============================================================================

function observeGenerator(initialize) {
  let dispose;
  let done = false;
  const queue = [];
  let notify;

  function enqueue(item) {
    queue.push(item);
    if (notify) {
      notify();
      notify = null;
    }
  }

  async function next() {
    if (done) return { value: undefined, done: true };
    if (!dispose) {
      dispose = initialize(
        (value) => enqueue({ type: "value", value }),
        (error) => enqueue({ type: "error", error })
      );
    }
    while (!queue.length) {
      await new Promise((r) => (notify = r));
      if (done) return { value: undefined, done: true };
    }
    const item = queue.shift();
    if (item.type === "error") throw item.error;
    return { value: item.value, done: false };
  }

  return {
    next,
    return() {
      done = true;
      if (dispose) dispose();
      if (notify) {
        notify();
        notify = null;
      }
      return Promise.resolve({ value: undefined, done: true });
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

function inputGenerator(element) {
  return observeGenerator((change) => {
    const event = eventof(element);
    const value = valueof(element);
    const inputted = () => change(valueof(element));
    element.addEventListener(event, inputted);
    if (value !== undefined) change(value);
    return () => element.removeEventListener(event, inputted);
  });
}

function valueof(element) {
  const input = element;
  const select = element;
  if ("type" in element) {
    switch (element.type) {
      case "range":
      case "number":
        return input.valueAsNumber;
      case "date":
        return input.valueAsDate;
      case "checkbox":
        return input.checked;
      case "file":
        return input.multiple ? input.files : input.files[0];
      case "select-multiple":
        return Array.from(select.selectedOptions, (o) => o.value);
    }
  }
  return input.value;
}

function eventof(element) {
  if ("type" in element) {
    switch (element.type) {
      case "button":
      case "submit":
      case "checkbox":
        return "click";
      case "file":
        return "change";
    }
  }
  return "input";
}

// ============================================================================
// Display runtime (vendored from notebook-kit)
// ============================================================================

/**
 * Display a value into a cell's root element.
 * If value is a DOM node, append it directly; otherwise wrap with Inspector.
 */
function displayValue(state, value) {
  const { root, expanded } = state;
  let node;
  if (isDisplayable(value, root)) {
    node = value;
  } else {
    // Wrap non-DOM values with Inspector
    const div = document.createElement("div");
    new Inspector(div).fulfilled(value);
    node = div;
  }
  // Append to root (handles DocumentFragment specially)
  if (node.nodeType === 11) {
    let child;
    while ((child = node.firstChild)) {
      root.appendChild(child);
    }
  } else {
    root.appendChild(node);
  }
}

function isDisplayable(value, root) {
  return (
    (value instanceof Element || value instanceof Text) &&
    value instanceof value.constructor &&
    (!value.parentNode || root.contains(value))
  );
}

function clearRoot(state) {
  state.autoclear = false;
  state.expanded = Array.from(state.root.childNodes, getExpanded);
  while (state.root.lastChild) state.root.lastChild.remove();
}

function getExpanded(node) {
  if (!isInspectorNode(node)) return;
  const expanded = node.querySelectorAll(".observablehq--expanded");
  if (expanded.length) return Array.from(expanded, (e) => getNodePath(node, e));
}

function isInspectorNode(node) {
  return node.nodeType === 1 && node.classList && node.classList.contains("observablehq");
}

function getNodePath(node, descendant) {
  const path = [];
  while (descendant !== node) {
    path.push(Array.prototype.indexOf.call(descendant.parentNode.childNodes, descendant));
    descendant = descendant.parentNode;
  }
  return path.reverse();
}

/**
 * Create an observer for a cell that handles autodisplay.
 */
function createObserver(state, cellMeta) {
  return {
    _error: false,
    pending() {
      if (this._error) {
        this._error = false;
        clearRoot(state);
      }
    },
    fulfilled(value) {
      if (cellMeta.autodisplay) {
        clearRoot(state);
        displayValue(state, value);
      }
      // Match notebook-kit observe(): clear on fulfilled when autoclear is set.
      else if (state.autoclear) {
        clearRoot(state);
      }
    },
    rejected(error) {
      console.error(error);
      this._error = true;
      clearRoot(state);
      const div = document.createElement("div");
      new Inspector(div).rejected(error);
      state.root.appendChild(div);
    }
  };
}

/**
 * Define a cell with shadow variable injection for display/view.
 * This mimics notebook-kit's define() function.
 */
function defineCell(main, state, cellMeta, bodyFn) {
  const { id, body, inputs = [], outputs = [], output, autodisplay } = cellMeta;
  const variables = state.variables;

  // This matches notebook-kit: the primary variable name is either the cell's
  // explicit output name, or a synthetic "cell {id}" name for multi-output cells.
  const vid = output ?? (outputs.length ? "cell " + id : null);

  const observer = createObserver(state, cellMeta);
  const v = main.variable(observer, { shadow: {} });
  state.autoclear = true;

  if (inputs.includes("display") || inputs.includes("view")) {
    let displayVersion = -1;
    const vd = new (v.constructor)(2, v._module);
    vd.define(
      inputs.filter((i) => i !== "display" && i !== "view"),
      () => {
        const version = v._version;
        return (value) => {
          if (version < displayVersion) throw new Error("stale display");
          else if (state.variables[0] !== v) throw new Error("stale display");
          else if (version > displayVersion) clearRoot(state);
          displayVersion = version;
          displayValue(state, value);
          return value;
        };
      }
    );
    v._shadow.set("display", vd);
    if (inputs.includes("view")) {
      const vv = new (v.constructor)(2, v._module, null, { shadow: {} });
      vv._shadow.set("display", vd);
      vv.define(["display"], (display) => (value) => inputGenerator(display(value)));
      v._shadow.set("view", vv);
    }
  } else if (!autodisplay) {
    clearRoot(state);
  }

  variables.push(v.define(vid, inputs, bodyFn));

  // Only project declarations when output is not set (matching notebook-kit).
  if (output == null) {
    for (const o of outputs) {
      variables.push(main.variable(true).define(o, [vid], (exports) => exports[o]));
    }
  }
}

// ============================================================================
// Mount function
// ============================================================================

/**
 * Mount the notebook into a container.
 *
 * This mirrors notebook-kit's runtime model:
 * - one DOM root per cell
 * - each cell renders into an element with id "cell-<id>"
 * - display() appends into the cell root (supports multiple calls)
 *
 * @param {Element} [container=document.body]
 * @returns {{ runtime: Runtime, main: Module }}
 */
export function mount(container = document.body) {

  const runtime = new Runtime();
  const main = runtime.module();
  const cellStates = new Map();

  // Define each cell with its own root element
  for (const cellMeta of cells) {
    const existing = document.getElementById("cell-" + cellMeta.id);
    const root = existing ?? document.createElement("div");
    root.classList.add("observablehq", "observablehq--cell");
    if (!existing) {
      root.id = "cell-" + cellMeta.id;
      container.appendChild(root);
    }

    // Create state for this cell
    const state = {
      root,
      expanded: [],
      variables: [],
      autoclear: true,
      version: 0
    };
    cellStates.set(cellMeta.id, state);

    // Get the body function for this cell
    const cellKey = \`cell_\${cellMeta.id.replace(/[^a-zA-Z0-9]/g, '_')}\`;
    const bodyFn = cellBodies[cellKey];

    if (bodyFn) {
      defineCell(main, state, cellMeta, bodyFn);
    }
  }

  return { runtime, main };
}
`;
}

export function generatePackageJson(
    name: string,
    detectedDependencies: Set<string>,
    dependencySpecs: Record<string, string> = {}
): string {
    const depsObj: Record<string, string> = {
        "@observablehq/runtime": "^5.0.0",
        "@observablehq/inspector": "latest",
        "@observablehq/stdlib": "latest",
        "@observablehq/inputs": "latest"
    };

    // Apply explicit specs (can override defaults)
    for (const [dep, spec] of Object.entries(dependencySpecs)) {
        depsObj[dep] = spec;
    }

    // Add detected dependencies
    // We default to "latest" because we extracted names but not versions
    detectedDependencies.forEach(dep => {
        if (!(dep in depsObj)) {
            depsObj[dep] = "latest";
        }
    });

    return JSON.stringify({
        name,
        version: "0.1.0",
        description: "Converted Observable Notebook",
        type: "module",
        main: "src/index.js",
        files: ["src"],
        dependencies: depsObj
    }, null, 2);
}

export function generateReadme(name: string): string {
    return `# ${name}

This library was generated from an Observable Notebook.

## Usage

\`\`\`javascript
import { mount } from "${name}";

// Renders one root per cell (notebook-kit semantics), supporting display() and view().
const { runtime } = mount(document.getElementById("notebook") ?? document.body);

// Later, when done:
// runtime.dispose();
\`\`\`

## Layout / Directing Output

This package uses notebook-kit style placement:

- Each cell renders into a DOM element with id \`cell-<id>\` (e.g. \`cell-4\`).
- If a matching element already exists anywhere in the document, \`mount()\` will render into it.
- Otherwise \`mount(container)\` will create the missing cell roots and append them to \`container\`.

Example:

\`\`\`html
<div id="notebook">
  <div id="cell-1"></div>
  <div id="cell-2"></div>
  <div id="cell-3"></div>
  <div id="cell-4"></div>
</div>
\`\`\`

## display()

Cells can call \`display(value)\` to imperatively append output into the current cellâ€™s root.
Multiple \`display(...)\` calls append multiple outputs, matching notebook-kit behavior.
`;
}
