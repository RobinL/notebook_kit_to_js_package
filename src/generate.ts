import type { TranspiledCell } from "./transpile.js";

export function generateDefineJs(cells: TranspiledCell[]): string {
    const lines: string[] = [
        `// Auto-generated by notebook-to-lib`,
        `export default function define(runtime, observer) {`,
        `  const main = runtime.module();`
    ];

    for (const cell of cells) {
        const inputs = JSON.stringify(cell.inputs);
        const cellFnName = `_${cell.id}`;

        // notebook-kit returns a function expression in transpiled.body.
        lines.push(`  const ${cellFnName} = ${cell.body};`);

        if (cell.outputs.length === 0) {
            // Anonymous / side-effect cell (e.g. markdown)
            if (cell.name) {
                lines.push(`  main.variable(observer("${cell.name}")).define(${inputs}, ${cellFnName});`);
            } else {
                lines.push(`  main.variable(observer()).define(${inputs}, ${cellFnName});`);
            }
            continue;
        }

        for (const output of cell.outputs) {
            if (output.startsWith("viewof ")) {
                const viewName = output.slice("viewof ".length);
                lines.push(
                    `  main.variable(observer(${JSON.stringify(output)})).define(${JSON.stringify(output)}, ${inputs}, (...args) => Promise.resolve(${cellFnName}(...args)).then((o) => (o && typeof o === "object" && ${JSON.stringify(viewName)} in o) ? o[${JSON.stringify(viewName)}] : o));`
                );

                // Standard Observable pattern: the value cell is derived from the view cell.
                // main.variable(observer("one")).define("one", ["Generators", "viewof one"], (G, _) => G.input(_));
                lines.push(
                    `  main.variable(observer(${JSON.stringify(viewName)})).define(${JSON.stringify(viewName)}, ["Generators", ${JSON.stringify(output)}], (G, _) => G.input(_));`
                );
            } else {
                lines.push(
                    `  main.variable(observer(${JSON.stringify(output)})).define(${JSON.stringify(output)}, ${inputs}, (...args) => Promise.resolve(${cellFnName}(...args)).then((o) => (o && typeof o === "object" && ${JSON.stringify(output)} in o) ? o[${JSON.stringify(output)}] : o));`
                );
            }
        }
    }

    lines.push(`  return main;`);
    lines.push(`}`);

    return lines.join("\n");
}

export function generateIndexJs(): string {
    return [
        `export { default } from "./define.js";`,
        `export { Runtime, Inspector, Library, Inputs, createLibrary } from "./runtime.js";`
    ].join("\n");
}

export function generateRuntimeJs(): string {
    return [
        `import { Runtime as ObservableRuntime } from "@observablehq/runtime";`,
        `import { Inspector } from "@observablehq/inspector";`,
        `import { Library } from "@observablehq/stdlib";`,
        `import * as Inputs from "@observablehq/inputs";`,
        ``,
        `export { Inspector, Library, Inputs };`,
        ``,
        `export function createLibrary() {`,
        `  const library = new Library();`,
        `  // notebook-kit HTML exports assume Inputs is globally available; we provide it via the library.`,
        `  return Object.assign(library, { Inputs });`,
        `}`,
        ``,
        `// Export a Runtime class that comes pre-wired with stdlib + Inputs so consumers can do:`,
        `//   new Runtime().module(define, Inspector.into(...))`,
        `export class Runtime extends ObservableRuntime {`,
        `  constructor(builtins = createLibrary()) {`,
        `    super(builtins);`,
        `  }`,
        `}`
    ].join("\n");
}

export function generatePackageJson(name: string, dependencies: Set<string>): string {
    const depsObj: Record<string, string> = {
        "@observablehq/runtime": "^5.0.0",
        "@observablehq/inspector": "latest",
        "@observablehq/stdlib": "latest",
        "@observablehq/inputs": "latest"
    };

    // Add detected dependencies
    // We default to "latest" because we extracted names but not versions
    dependencies.forEach(dep => {
        depsObj[dep] = "latest";
    });

    return JSON.stringify({
        name,
        version: "0.1.0",
        description: "Converted Observable Notebook",
        type: "module",
        main: "src/index.js",
        files: ["src"],
        dependencies: depsObj
    }, null, 2);
}

export function generateReadme(name: string): string {
    return `# ${name}

This library was generated from an Observable Notebook.

## Usage

\`\`\`javascript
import define from "${name}";
import { Runtime, Inspector } from "${name}";

new Runtime().module(define, Inspector.into(document.body));
\`\`\`
`;
}
