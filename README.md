# notebook-to-lib

> Convert Observable notebook-kit HTML files into reusable JavaScript libraries

## Overview

**notebook-to-lib** transforms Observable notebook-kit notebooks into standard npm packages that export Observable Runtime compatible modules. Instead of bundling everything into a single HTML file, this tool creates a proper JavaScript library with dependencies managed through npm.

### Why Use This?

- **Reusable Components**: Convert notebooks into libraries that can be imported in other projects
- **Standard Tooling**: Leverage npm for dependency management and standard ES modules
- **Clean Integration**: Use notebook code in larger applications without bundling complexity
- **Simple Implementation**: ~400 lines of code vs 2000+ for a bundler approach
- **Active Development**: Perfect for sharing notebook logic and building on top of notebook work

## Features

âœ… **Smart Import Detection**: Automatically finds `npm:package` and bare specifier imports
âœ… **Dependency Management**: Generates `package.json` with all detected dependencies
âœ… **Observable Runtime Compatible**: Output works seamlessly with `@observablehq/runtime`
âœ… **TypeScript Built**: Full TypeScript implementation with type safety
âœ… **Multiple Outputs Handling**: Correctly handles cells with multiple variable definitions
âœ… **Markdown Support**: Preserves markdown cells with proper `md` template literals

## Installation

```bash
npm install
npm run build
```

## Quick Start

### 1. Convert a Notebook

```bash
# Using npm script
npm run test

# Or directly with tsx
npx tsx bin/convert.ts <input-notebook.html> --out <output-directory>

# Example
npx tsx bin/convert.ts test-notebooks/hello.html --out my-lib
```

### 2. Install Dependencies

```bash
cd my-lib
npm install
```

### 3. Use in Your Project

```javascript
import { Runtime, Inspector } from "@observablehq/runtime";
import define from "./my-lib/src/index.js";

const runtime = new Runtime();
const main = runtime.module(define, Inspector.into(document.body));
```

## How It Works

The conversion process involves four main steps:

```
Notebook HTML
    â†“ parse
Raw Cells
    â†“ transpile (notebook-kit)
Transpiled JavaScript
    â†“ analyze imports
Dependencies List
    â†“ generate
Library Package (with package.json)
    â†“ npm install
Ready to use with node_modules
```

### 1. **Parse**
Extracts cells from the notebook HTML file, identifying:
- Code cells (JavaScript/Observable JavaScript)
- Markdown cells
- Cell names from `data-name` attributes

### 2. **Transpile**
Uses `@observablehq/notebook-kit` to convert Observable JavaScript to standard JavaScript:
- Converts OJS syntax to standard JS
- Preserves cell relationships and dependencies
- Handles Observable-specific features

### 3. **Analyze & Rewrite**
Scans for dependencies and rewrites imports:
- `npm:d3` â†’ `d3` (bare specifier)
- `npm:diff-match-patch` â†’ `diff-match-patch`
- Detects already-bare specifiers like `"lodash"`
- Collects all dependencies for `package.json`

### 4. **Generate**
Creates a complete npm package:
```
output-directory/
â”œâ”€â”€ package.json         # Name, version, dependencies
â”œâ”€â”€ README.md           # Usage instructions
â””â”€â”€ src/
    â”œâ”€â”€ index.js        # Entry point (re-exports define)
    â””â”€â”€ define.js       # Observable Runtime module definition
```

## Example Transformation

### Input: Notebook HTML

```html
<!doctype html>
<title>Simple Test</title>

<script type="text/markdown">
# Test Notebook
This is a simple test.
</script>

<script type="module">
import * as d3 from "npm:d3";
const data = [1, 2, 3, 4, 5];
const sum = d3.sum(data);
</script>

<script type="text/markdown">
The sum is ${sum}
</script>
```

### Output: JavaScript Package

**package.json**
```json
{
  "name": "simple-test",
  "version": "0.1.0",
  "description": "Converted Observable Notebook",
  "type": "module",
  "main": "src/index.js",
  "files": ["src"],
  "dependencies": {
    "@observablehq/runtime": "^5.0.0",
    "d3": "latest"
  }
}
```

**src/define.js**
```javascript
// Auto-generated by notebook-to-lib
export default function define(runtime, observer) {
  const main = runtime.module();

  main.variable(observer()).define(["md"], (md) => md`
    # Test Notebook
    This is a simple test.
  `);

  main.variable(observer("sum")).define("sum", ["d3"], async (d3) => {
    const data = [1, 2, 3, 4, 5];
    return d3.sum(data);
  });

  main.variable(observer()).define(["md","sum"], (md, sum) => md`
    The sum is ${sum}
  `);

  return main;
}
```

**src/index.js**
```javascript
export { default } from "./define.js";
```

## CLI Reference

```bash
npx tsx bin/convert.ts <input.html> [options]

Options:
  --out <directory>    Output directory for generated library
                       (default: derived from input filename)
```

## When to Use This vs a Bundler

| Feature | notebook-to-lib (This Tool) | Bundler Approach |
|---------|----------------------------|------------------|
| **Output** | JavaScript library package | Single HTML file |
| **Dependencies** | Managed by npm | Bundled into HTML |
| **Usage** | Import in other projects | Open HTML file in browser |
| **Complexity** | Simple (delegates to npm/JS) | Complex (shimming, bundling) |
| **File Size** | Small (deps separate) | Large (everything bundled) |
| **Offline** | Requires node_modules | Fully self-contained |
| **Reusability** | High (standard npm package) | Low (monolithic file) |

### Use notebook-to-lib when you want to:
- âœ… Create reusable components from notebooks
- âœ… Integrate notebook code into larger applications
- âœ… Leverage standard npm tooling
- âœ… Keep dependencies up-to-date independently
- âœ… Share code between multiple projects

### Use a bundler approach when you need:
- âœ… Completely self-contained HTML files
- âœ… No build step or npm dependencies
- âœ… Easy distribution (just share one file)
- âœ… Offline viewing without any setup
- âœ… Simple deployment (single file upload)

### Key Insight

The library approach is **much simpler** because it leverages existing infrastructure:
- npm handles dependency resolution
- Node.js/browsers handle module loading
- No need to shim FileAttachment, import.meta, etc.
- Standard Observable Runtime usage pattern

The bundler is **more complex** but produces **more portable** output.

## Project Structure

```
notebook-to-lib/
â”œâ”€â”€ bin/
â”‚   â””â”€â”€ convert.ts          # CLI entry point
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ parse.ts            # HTML parsing logic
â”‚   â”œâ”€â”€ transpile.ts        # OJS â†’ JS conversion
â”‚   â”œâ”€â”€ rewrite.ts          # Import detection & rewriting
â”‚   â””â”€â”€ generate.ts         # Package generation
â”œâ”€â”€ test-notebooks/
â”‚   â”œâ”€â”€ hello.html          # Complex test case
â”‚   â”œâ”€â”€ simple-test.html    # Simple test case
â”‚   â””â”€â”€ my-custom-lib/      # Custom dependency example
â”œâ”€â”€ test-lib/               # Generated from hello.html
â”œâ”€â”€ simple-test-lib/        # Generated from simple-test.html
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ README.md               # This file
â””â”€â”€ ARCHITECTURE.md         # Design comparison
```

## Testing

The repository includes test notebooks:

- **hello.html**: Complex notebook with markdown, Observable Inputs, and external dependencies
- **simple-test.html**: Basic notebook with D3 for simple testing

Run the conversion test:

```bash
npm run test
```

This generates `test-lib` and `simple-test-lib` directories with complete, installable packages.

## Requirements

### Build Requirements
- Node.js 18+
- TypeScript 5+

### Runtime Requirements (Generated Libraries)
- `@observablehq/runtime` (automatically added to dependencies)
- Any npm packages imported in the notebook
- A JavaScript environment (Node.js or browser with bundler)

## Implementation Details

### Key Design Decisions

1. **Delegation over Bundling**: Uses npm and standard module resolution instead of custom bundling
2. **No Shimming Required**: Doesn't need to fake `FileAttachment`, `import.meta`, etc.
3. **Simple Architecture**: ~400 lines of focused code instead of complex bundler configuration
4. **Observable Runtime Native**: Output is standard Observable Runtime module format

### Advantages

- **Simplicity**: Much easier to maintain than bundler approach
- **Standard Tooling**: Works with existing npm ecosystem
- **Reusability**: Output is a standard npm package
- **Maintainability**: Delegates complexity to existing, well-maintained tools

### Trade-offs

- Requires `npm install` (not standalone)
- Needs Node.js or bundler environment
- Not suitable for single-file distribution

## Contributing

This is a complete, working implementation. For modifications:

1. Edit TypeScript files in `src/` or `bin/`
2. Build: `npm run build`
3. Test: `npm run test`

## License

MIT

---

## Usage Examples

### Example 1: Simple Render (No Targeting)

The simplest way to render a notebook â€“ just mount everything into a container:

**HTML:**
```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Simple Notebook</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@observablehq/inspector@5/dist/inspector.css">
</head>
<body>
  <h1>My Notebook</h1>
  <div id="notebook"></div>
  <script type="module" src="/src/main.js"></script>
</body>
</html>
```

**main.js:**
```javascript
import { mount } from "hello-world-diff-match-patch-demo";

// Render everything into #notebook
mount(document.getElementById("notebook"));
```

That's it! All cells render in order inside `#notebook`.

---

### Example 2: Targeted Rendering with `data-cell`

For custom layouts, use `data-cell` attributes to place specific cells into specific DOM elements.

In your notebook HTML, name your cells with `data-name`:

```html
<notebook>
    <script type="module" data-name="one">
        const one = view(Inputs.text({ label: "one", value: "robin" }));
        ({ one })
    </script>

    <script type="module" data-name="other">
        const other = view(Inputs.text({ label: "other", value: "Roin" }));
        ({ other })
    </script>

    <script type="module" data-name="out">
        import DiffMatchPatch from "diff-match-patch";
        const dmp = new DiffMatchPatch();
        display(dmp.diff_prettyHtml(dmp.diff_main(one, other)));
    </script>
</notebook>
```

Then in your HTML template, use `data-cell` to target where each cell renders:

**HTML:**
```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Custom Layout</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@observablehq/inspector@5/dist/inspector.css">
  <style>
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
    .card { padding: 1rem; border: 1px solid #ccc; border-radius: 8px; }
    .full-width { grid-column: 1 / -1; }
  </style>
</head>
<body>
  <h1>ðŸ”¤ Diff Match Patch</h1>

  <div class="grid">
    <div class="card">
      <h3>Original Text</h3>
      <div data-cell="one"></div>
    </div>

    <div class="card">
      <h3>Comparison Text</h3>
      <div data-cell="other"></div>
    </div>
  </div>

  <div class="card full-width">
    <h3>Diff Result</h3>
    <div data-cell="out"></div>
  </div>

  <!-- Container for any unmatched cells (e.g. markdown) -->
  <div id="notebook"></div>

  <script type="module" src="/src/main.js"></script>
</body>
</html>
```

**main.js:**
```javascript
import { mount } from "hello-world-diff-match-patch-demo";

// Mount with data-cell targeting; unmatched cells go to #notebook
mount(document.getElementById("notebook"));
```

The `mount()` function automatically:
1. Finds `[data-cell="one"]`, `[data-cell="other"]`, `[data-cell="out"]` in the document
2. Renders those cells into their targeted elements
3. Appends any unmatched cells (like markdown) to the container

---

### Example 3: Programmatic Targeting

You can also pass a `targets` map for programmatic control:

```javascript
import { mount } from "hello-world-diff-match-patch-demo";

mount(document.body, {
  targets: {
    "one": document.getElementById("target-one"),
    "other": document.getElementById("target-other"),
    "out": document.getElementById("target-result"),
  },
  appendUnmatched: false  // Hide cells without explicit targets
});
```

---

### Example 4: Fallback Cell IDs

Every cell also has a stable `cell:<index>` identifier (0-based), so you can target cells even without a `data-name`:

```html
<!-- Target the 3rd cell (index 2) -->
<div data-cell="cell:2"></div>
```

---

### Cleanup (for HMR / SPA)

The `mount()` function returns the runtime for cleanup:

```javascript
const { runtime } = mount(document.getElementById("notebook"));

// Later, when unmounting:
runtime.dispose();
```

---

**Created**: January 2026
**Built with**: TypeScript, @observablehq/notebook-kit, Observable Runtime
