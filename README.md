# notebook-to-lib

> Convert Observable notebook-kit HTML files into reusable JavaScript libraries

## Overview

**notebook-to-lib** transforms Observable notebook-kit notebooks into standard npm packages that export Observable Runtime compatible modules. Instead of bundling everything into a single HTML file, this tool creates a proper JavaScript library with dependencies managed through npm.

### Why Use This?

- **Reusable Components**: Convert notebooks into libraries that can be imported in other projects
- **Standard Tooling**: Leverage npm for dependency management and standard ES modules
- **Clean Integration**: Use notebook code in larger applications without bundling complexity
- **Simple Implementation**: ~400 lines of code vs 2000+ for a bundler approach
- **Active Development**: Perfect for sharing notebook logic and building on top of notebook work

## Features

âœ… **Smart Import Detection**: Automatically finds `npm:package` and bare specifier imports
âœ… **Dependency Management**: Generates `package.json` with all detected dependencies
âœ… **Observable Runtime Compatible**: Output works seamlessly with `@observablehq/runtime`
âœ… **TypeScript Built**: Full TypeScript implementation with type safety
âœ… **Multiple Outputs Handling**: Correctly handles cells with multiple variable definitions
âœ… **Markdown Support**: Preserves markdown cells with proper `md` template literals

## Installation

```bash
npm install
npm run build
```

## Quick Start

### 1. Convert a Notebook

```bash
# Using npm script
npm run test

# Or directly with tsx
npx tsx bin/convert.ts <input-notebook.html> --out <output-directory>

# Example
npx tsx bin/convert.ts test-notebooks/hello.html --out my-lib
```

### 2. Install Dependencies

```bash
cd my-lib
npm install
```

### 3. Use in Your Project

```javascript
import { Runtime, Inspector } from "@observablehq/runtime";
import define from "./my-lib/src/index.js";

const runtime = new Runtime();
const main = runtime.module(define, Inspector.into(document.body));
```

## How It Works

The conversion process involves four main steps:

```
Notebook HTML
    â†“ parse
Raw Cells
    â†“ transpile (notebook-kit)
Transpiled JavaScript
    â†“ analyze imports
Dependencies List
    â†“ generate
Library Package (with package.json)
    â†“ npm install
Ready to use with node_modules
```

### 1. **Parse**
Extracts cells from the notebook HTML file, identifying:
- Code cells (JavaScript/Observable JavaScript)
- Markdown cells
- Cell names from `data-name` attributes

### 2. **Transpile**
Uses `@observablehq/notebook-kit` to convert Observable JavaScript to standard JavaScript:
- Converts OJS syntax to standard JS
- Preserves cell relationships and dependencies
- Handles Observable-specific features

### 3. **Analyze & Rewrite**
Scans for dependencies and rewrites imports:
- `npm:d3` â†’ `d3` (bare specifier)
- `npm:diff-match-patch` â†’ `diff-match-patch`
- Detects already-bare specifiers like `"lodash"`
- Collects all dependencies for `package.json`

### 4. **Generate**
Creates a complete npm package:
```
output-directory/
â”œâ”€â”€ package.json         # Name, version, dependencies
â”œâ”€â”€ README.md           # Usage instructions
â””â”€â”€ src/
    â”œâ”€â”€ index.js        # Entry point (re-exports define)
    â””â”€â”€ define.js       # Observable Runtime module definition
```

## Example Transformation

### Input: Notebook HTML

```html
<!doctype html>
<title>Simple Test</title>

<script type="text/markdown">
# Test Notebook
This is a simple test.
</script>

<script type="module">
import * as d3 from "npm:d3";
const data = [1, 2, 3, 4, 5];
const sum = d3.sum(data);
</script>

<script type="text/markdown">
The sum is ${sum}
</script>
```

### Output: JavaScript Package

**package.json**
```json
{
  "name": "simple-test",
  "version": "0.1.0",
  "description": "Converted Observable Notebook",
  "type": "module",
  "main": "src/index.js",
  "files": ["src"],
  "dependencies": {
    "@observablehq/runtime": "^5.0.0",
    "d3": "latest"
  }
}
```

**src/define.js**
```javascript
// Auto-generated by notebook-to-lib
export default function define(runtime, observer) {
  const main = runtime.module();

  main.variable(observer()).define(["md"], (md) => md`
    # Test Notebook
    This is a simple test.
  `);

  main.variable(observer("sum")).define("sum", ["d3"], async (d3) => {
    const data = [1, 2, 3, 4, 5];
    return d3.sum(data);
  });

  main.variable(observer()).define(["md","sum"], (md, sum) => md`
    The sum is ${sum}
  `);

  return main;
}
```

**src/index.js**
```javascript
export { default } from "./define.js";
```

## CLI Reference

```bash
npx tsx bin/convert.ts <input.html> [options]

Options:
  --out <directory>    Output directory for generated library
                       (default: derived from input filename)
```

## When to Use This vs a Bundler

| Feature | notebook-to-lib (This Tool) | Bundler Approach |
|---------|----------------------------|------------------|
| **Output** | JavaScript library package | Single HTML file |
| **Dependencies** | Managed by npm | Bundled into HTML |
| **Usage** | Import in other projects | Open HTML file in browser |
| **Complexity** | Simple (delegates to npm/JS) | Complex (shimming, bundling) |
| **File Size** | Small (deps separate) | Large (everything bundled) |
| **Offline** | Requires node_modules | Fully self-contained |
| **Reusability** | High (standard npm package) | Low (monolithic file) |

### Use notebook-to-lib when you want to:
- âœ… Create reusable components from notebooks
- âœ… Integrate notebook code into larger applications
- âœ… Leverage standard npm tooling
- âœ… Keep dependencies up-to-date independently
- âœ… Share code between multiple projects

### Use a bundler approach when you need:
- âœ… Completely self-contained HTML files
- âœ… No build step or npm dependencies
- âœ… Easy distribution (just share one file)
- âœ… Offline viewing without any setup
- âœ… Simple deployment (single file upload)

### Key Insight

The library approach is **much simpler** because it leverages existing infrastructure:
- npm handles dependency resolution
- Node.js/browsers handle module loading
- No need to shim FileAttachment, import.meta, etc.
- Standard Observable Runtime usage pattern

The bundler is **more complex** but produces **more portable** output.

## Project Structure

```
notebook-to-lib/
â”œâ”€â”€ bin/
â”‚   â””â”€â”€ convert.ts          # CLI entry point
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ parse.ts            # HTML parsing logic
â”‚   â”œâ”€â”€ transpile.ts        # OJS â†’ JS conversion
â”‚   â”œâ”€â”€ rewrite.ts          # Import detection & rewriting
â”‚   â””â”€â”€ generate.ts         # Package generation
â”œâ”€â”€ test-notebooks/
â”‚   â”œâ”€â”€ hello.html          # Complex test case
â”‚   â”œâ”€â”€ simple-test.html    # Simple test case
â”‚   â””â”€â”€ my-custom-lib/      # Custom dependency example
â”œâ”€â”€ test-lib/               # Generated from hello.html
â”œâ”€â”€ simple-test-lib/        # Generated from simple-test.html
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ README.md               # This file
â””â”€â”€ ARCHITECTURE.md         # Design comparison
```

## Testing

The repository includes test notebooks:

- **hello.html**: Complex notebook with markdown, Observable Inputs, and external dependencies
- **simple-test.html**: Basic notebook with D3 for simple testing

Run the conversion test:

```bash
npm run test
```

This generates `test-lib` and `simple-test-lib` directories with complete, installable packages.

## Requirements

### Build Requirements
- Node.js 18+
- TypeScript 5+

### Runtime Requirements (Generated Libraries)
- `@observablehq/runtime` (automatically added to dependencies)
- Any npm packages imported in the notebook
- A JavaScript environment (Node.js or browser with bundler)

## Implementation Details

### Key Design Decisions

1. **Delegation over Bundling**: Uses npm and standard module resolution instead of custom bundling
2. **No Shimming Required**: Doesn't need to fake `FileAttachment`, `import.meta`, etc.
3. **Simple Architecture**: ~400 lines of focused code instead of complex bundler configuration
4. **Observable Runtime Native**: Output is standard Observable Runtime module format

### Advantages

- **Simplicity**: Much easier to maintain than bundler approach
- **Standard Tooling**: Works with existing npm ecosystem
- **Reusability**: Output is a standard npm package
- **Maintainability**: Delegates complexity to existing, well-maintained tools

### Trade-offs

- Requires `npm install` (not standalone)
- Needs Node.js or bundler environment
- Not suitable for single-file distribution

## Contributing

This is a complete, working implementation. For modifications:

1. Edit TypeScript files in `src/` or `bin/`
2. Build: `npm run build`
3. Test: `npm run test`

## License

MIT


##

```index.html
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Notebook Kit: Custom Layout</title>




  <style>

  </style>
</head>

<body>
  <h1>ðŸ”¤ Diff Match Patch: Custom Layout</h1>

  <!-- 1. The Inputs Grid -->
  <div class="grid">
    <div class="card">
      <h3>Original Text</h3>
      <div id="target-one"></div> <!-- Target for 'viewof one' -->
    </div>

    <div class="card">
      <h3>Comparison Text</h3>
      <div id="target-other"></div> <!-- Target for 'viewof other' -->
    </div>
  </div>

  <!-- 2. The Output Area -->
  <div class="card full-width">
    <h3>Diff Result</h3>
    <div id="target-result"></div> <!-- Target for 'out' -->
  </div>

  <script type="module" src="/src/main.ts"></script>
</body>

</html>
```

```main.ts
import define, { Runtime, Inspector, createLibrary } from "hello-world-diff-match-patch-demo";

const runtime = new Runtime(createLibrary());

runtime.module(define, (name) => {
  switch (name) {
    case "viewof one":
      return new Inspector(document.getElementById("target-one")!);

    case "viewof other":
      return new Inspector(document.getElementById("target-other")!);

    case "out":
      return new Inspector(document.getElementById("target-result")!);

    default:
      return true;
  }
});

if (import.meta.hot) {
  import.meta.hot.dispose(() => {
    runtime.dispose();

    ["target-one", "target-other", "target-result"].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.innerHTML = "";
    });
  });
}
```

---

**Created**: January 2026
**Built with**: TypeScript, @observablehq/notebook-kit, Observable Runtime
