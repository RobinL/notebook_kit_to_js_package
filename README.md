# notebook-to-lib

> Convert Observable notebook-kit HTML files into reusable JavaScript libraries

## Overview

**notebook-to-lib** transforms Observable notebook-kit notebooks into standard npm packages that export Observable Runtime compatible modules. Instead of bundling everything into a single HTML file, this tool creates a proper JavaScript library with dependencies managed through npm.

### Why Use This?

- **Reusable Components**: Convert notebooks into libraries that can be imported in other projects
- **Standard Tooling**: Leverage npm for dependency management and standard ES modules
- **Clean Integration**: Use notebook code in larger applications without bundling complexity
- **Simple Implementation**: ~400 lines of code vs 2000+ for a bundler approach
- **Active Development**: Perfect for sharing notebook logic and building on top of notebook work

## Features

✅ **Smart Import Detection**: Automatically finds `npm:package` and bare specifier imports
✅ **Dependency Management**: Generates `package.json` with all detected dependencies
✅ **Observable Runtime Compatible**: Output works seamlessly with `@observablehq/runtime`
✅ **TypeScript Built**: Full TypeScript implementation with type safety
✅ **Multiple Outputs Handling**: Correctly handles cells with multiple variable definitions
✅ **Markdown Support**: Preserves markdown cells with proper `md` template literals

## Installation

```bash
npm install
npm run build
```

## Quick Start

### 1. Convert a Notebook

```bash
# Using npm script
npm run test

# Or directly with tsx
npx tsx bin/convert.ts <input-notebook.html> --out <output-directory>

# Example
npx tsx bin/convert.ts test-notebooks/hello.html --out my-lib
```

### 2. Install Dependencies

```bash
cd my-lib
npm install
```

### 3. Use in Your Project

```javascript
import { Runtime, Inspector } from "@observablehq/runtime";
import define from "./my-lib/src/index.js";

const runtime = new Runtime();
const main = runtime.module(define, Inspector.into(document.body));
```

## How It Works

The conversion process involves four main steps:

```
Notebook HTML
    ↓ parse
Raw Cells
    ↓ transpile (notebook-kit)
Transpiled JavaScript
    ↓ analyze imports
Dependencies List
    ↓ generate
Library Package (with package.json)
    ↓ npm install
Ready to use with node_modules
```

### 1. **Parse**
Extracts cells from the notebook HTML file, identifying:
- Code cells (JavaScript/Observable JavaScript)
- Markdown cells
- Cell names from `data-name` attributes

### 2. **Transpile**
Uses `@observablehq/notebook-kit` to convert Observable JavaScript to standard JavaScript:
- Converts OJS syntax to standard JS
- Preserves cell relationships and dependencies
- Handles Observable-specific features

### 3. **Analyze & Rewrite**
Scans for dependencies and rewrites imports:
- `npm:d3` → `d3` (bare specifier)
- `npm:diff-match-patch` → `diff-match-patch`
- Detects already-bare specifiers like `"lodash"`
- Collects all dependencies for `package.json`

### 4. **Generate**
Creates a complete npm package:
```
output-directory/
├── package.json         # Name, version, dependencies
├── README.md           # Usage instructions
└── src/
    ├── index.js        # Entry point (re-exports define)
    └── define.js       # Observable Runtime module definition
```

## Example Transformation

### Input: Notebook HTML

```html
<!doctype html>
<title>Simple Test</title>

<script type="text/markdown">
# Test Notebook
This is a simple test.
</script>

<script type="module">
import * as d3 from "npm:d3";
const data = [1, 2, 3, 4, 5];
const sum = d3.sum(data);
</script>

<script type="text/markdown">
The sum is ${sum}
</script>
```

### Output: JavaScript Package

**package.json**
```json
{
  "name": "simple-test",
  "version": "0.1.0",
  "description": "Converted Observable Notebook",
  "type": "module",
  "main": "src/index.js",
  "files": ["src"],
  "dependencies": {
    "@observablehq/runtime": "^5.0.0",
    "d3": "latest"
  }
}
```

**src/define.js**
```javascript
// Auto-generated by notebook-to-lib
export default function define(runtime, observer) {
  const main = runtime.module();

  main.variable(observer()).define(["md"], (md) => md`
    # Test Notebook
    This is a simple test.
  `);

  main.variable(observer("sum")).define("sum", ["d3"], async (d3) => {
    const data = [1, 2, 3, 4, 5];
    return d3.sum(data);
  });

  main.variable(observer()).define(["md","sum"], (md, sum) => md`
    The sum is ${sum}
  `);

  return main;
}
```

**src/index.js**
```javascript
export { default } from "./define.js";
```

## CLI Reference

```bash
npx tsx bin/convert.ts <input.html> [options]

Options:
  --out <directory>    Output directory for generated library
                       (default: derived from input filename)
```

## When to Use This vs a Bundler

| Feature | notebook-to-lib (This Tool) | Bundler Approach |
|---------|----------------------------|------------------|
| **Output** | JavaScript library package | Single HTML file |
| **Dependencies** | Managed by npm | Bundled into HTML |
| **Usage** | Import in other projects | Open HTML file in browser |
| **Complexity** | Simple (delegates to npm/JS) | Complex (shimming, bundling) |
| **File Size** | Small (deps separate) | Large (everything bundled) |
| **Offline** | Requires node_modules | Fully self-contained |
| **Reusability** | High (standard npm package) | Low (monolithic file) |

### Use notebook-to-lib when you want to:
- ✅ Create reusable components from notebooks
- ✅ Integrate notebook code into larger applications
- ✅ Leverage standard npm tooling
- ✅ Keep dependencies up-to-date independently
- ✅ Share code between multiple projects

### Use a bundler approach when you need:
- ✅ Completely self-contained HTML files
- ✅ No build step or npm dependencies
- ✅ Easy distribution (just share one file)
- ✅ Offline viewing without any setup
- ✅ Simple deployment (single file upload)

### Key Insight

The library approach is **much simpler** because it leverages existing infrastructure:
- npm handles dependency resolution
- Node.js/browsers handle module loading
- No need to shim FileAttachment, import.meta, etc.
- Standard Observable Runtime usage pattern

The bundler is **more complex** but produces **more portable** output.

## Project Structure

```
notebook-to-lib/
├── bin/
│   └── convert.ts          # CLI entry point
├── src/
│   ├── parse.ts            # HTML parsing logic
│   ├── transpile.ts        # OJS → JS conversion
│   ├── rewrite.ts          # Import detection & rewriting
│   └── generate.ts         # Package generation
├── test-notebooks/
│   ├── hello.html          # Complex test case
│   ├── simple-test.html    # Simple test case
│   └── my-custom-lib/      # Custom dependency example
├── test-lib/               # Generated from hello.html
├── simple-test-lib/        # Generated from simple-test.html
├── package.json
├── tsconfig.json
├── README.md               # This file
└── ARCHITECTURE.md         # Design comparison
```

## Testing

The repository includes test notebooks:

- **hello.html**: Complex notebook with markdown, Observable Inputs, and external dependencies
- **simple-test.html**: Basic notebook with D3 for simple testing

Run the conversion test:

```bash
npm run test
```

This generates `test-lib` and `simple-test-lib` directories with complete, installable packages.

## Requirements

### Build Requirements
- Node.js 18+
- TypeScript 5+

### Runtime Requirements (Generated Libraries)
- `@observablehq/runtime` (automatically added to dependencies)
- Any npm packages imported in the notebook
- A JavaScript environment (Node.js or browser with bundler)

## Implementation Details

### Key Design Decisions

1. **Delegation over Bundling**: Uses npm and standard module resolution instead of custom bundling
2. **No Shimming Required**: Doesn't need to fake `FileAttachment`, `import.meta`, etc.
3. **Simple Architecture**: ~400 lines of focused code instead of complex bundler configuration
4. **Observable Runtime Native**: Output is standard Observable Runtime module format

### Advantages

- **Simplicity**: Much easier to maintain than bundler approach
- **Standard Tooling**: Works with existing npm ecosystem
- **Reusability**: Output is a standard npm package
- **Maintainability**: Delegates complexity to existing, well-maintained tools

### Trade-offs

- Requires `npm install` (not standalone)
- Needs Node.js or bundler environment
- Not suitable for single-file distribution

## Contributing

This is a complete, working implementation. For modifications:

1. Edit TypeScript files in `src/` or `bin/`
2. Build: `npm run build`
3. Test: `npm run test`

## License

MIT

---

**Created**: January 2026
**Built with**: TypeScript, @observablehq/notebook-kit, Observable Runtime
